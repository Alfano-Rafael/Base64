//---------------------------------------------------------------------------

#pragma hdrstop

#include "Base64.h"

#include <stdio.h>
#include <iostream>
using namespace std;

Base64::Base64(){
}

void Base64::InitialiserTable(){
	int curseur=0;
    //initialiser table
		//ABC...
		for(char i='A'; i<='Z'; i++){
			tableBase64[curseur]= i;
			curseur++ ;
		}
		//abc...
		for(char i='a'; i<='z'; i++){
			tableBase64[curseur]= i;
			curseur++ ;
		}
		//012...
		for(char i='0'; i<='9'; i++){
			tableBase64[curseur]= i;
			curseur++ ;
		}

		tableBase64[curseur]={'+'};
		curseur++;
		tableBase64[curseur]={'/'};

}


void Base64::AfficherTable(){
   //OUTPUT

	for (int k=0; k < 64; k++) {
		cout<<k<<"    ";
		cout<<(char)tableBase64[k]<<"    ";

		AfficherBinaire(k, 6);
		cout<<endl;

	}

}


void Base64::AfficherBinaire(int entier, int nbBits) {
  for(int i=0;i<nbBits;i++) cout<<((entier>>(nbBits-i-1))&0x01);
}

void Base64::Code3OctetsBase64(unsigned char* donnee, char*code){
	int nb24bits,i;
	nb24bits = (donnee[0] << 16)+(donnee[1] << 8) + donnee[2];
	//nb24bit est la concatenation de tout les octets de donnee
	//AfficherBinaire(nb24bits, 24);
	//afficher nb24bit
	code[4] = '\0';
	//caractere de fin de chaine 0
	i = nb24bits & 0x3f;
	//garder que 6 bit sur les 24bit
	code[3] = tableBase64[i];
	//prendre les 6 bits et utiliser le base64 correspondant
	nb24bits>>=6;
	//remplacer les 6prochains bits
	i = nb24bits & 0x3f;
	code[2] = tableBase64[i];
	nb24bits>>=6;
	i = nb24bits & 0x3f;
	code[1] = tableBase64[i];
	nb24bits>>=6;
	i = nb24bits & 0x3f;
	code[0] = tableBase64[i];
}

int  Base64::IndiceCaractereBase64(char c){

	if ( (c >= 'A') && (c<='Z') )
		return c -'A';

	else if ( (c >= 'a') && (c<='z') )
		return c - 'a' + 26;

	else if ( (c >= '0') && (c<='9') )
		return c - '0' + 52;

	else if (c=='+') return 62;

	else if (c=='/') return 63;

	else return 64;

}

void Base64::Decode4caracteresBase64(unsigned char* donnee, char* code){

	int nb24bits;

	nb24bits = (IndiceCaractereBase64(code[0])<<18)+ (IndiceCaractereBase64(code[1])<<12) + (IndiceCaractereBase64(code[2])<<6) +IndiceCaractereBase64(code[3]);
	//AfficherBinaire(nb24bits, 24);

	donnee[2]= nb24bits & 0xff;
	nb24bits = nb24bits>>=8;
	donnee[1]= nb24bits & 0xff;
	nb24bits = nb24bits>>=8;
	donnee[0]= nb24bits & 0xff;

	cout<<hex<<(int)donnee[0]<<" "<<(int)donnee[1]<<" "<<(int)donnee[2];

}

void Base64::CodeNoctetsBase64(unsigned char* donnee, int nbOctetsDonnees, char* code){

	int resteEnFinDeSequence= (nbOctetsDonnees*8) %24 ;
	//recuperer le nombre de bits retants apres le modulo de 3 octets
	cout << "reste en fin de secance : "<<resteEnFinDeSequence<<endl;

	if (resteEnFinDeSequence == 16) {
		donnee[nbOctetsDonnees] = 0;
		nbOctetsDonnees++;
	}
	if (resteEnFinDeSequence == 8) {
		donnee[nbOctetsDonnees] = 0;
		nbOctetsDonnees++;
		donnee[nbOctetsDonnees] = 0;
		nbOctetsDonnees++;
	}

	int j =0;

	for (int i = 0; i < nbOctetsDonnees ; i+=3) {
		Code3OctetsBase64(donnee+i, code+j);
		j+=4;
	}

	if (resteEnFinDeSequence == 16) {
	code[strlen(code)-1]='=';
	}
	if (resteEnFinDeSequence == 8) {
	code[strlen(code)-1]='=';
	code[strlen(code)-2]='=';
	}
    cout << "le code est" << code <<endl;
}

int Base64::DecodeNoctetsBase64(unsigned char* donnee, char* code){
	int j = 0;
	for (int i = 0; i < strlen(code); i+=4) {
		Decode4caracteresBase64(donnee+j, code+i);
		j+=3;
	}
	if (strlen(code)-1=='=') {
		j--;
	}
	if (strlen(code)-2=='=') {
		j--;
	}
    return j;
}






//---------------------------------------------------------------------------
#pragma package(smart_init)

