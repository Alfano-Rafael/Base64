//---------------------------------------------------------------------------

#pragma hdrstop

#include "Base64.h"

#include <stdio.h>
#include <iostream>
using namespace std;

Base64::Base64(){
}

void Base64::InitialiserTable(){
	int curseur=0;
    //initialiser table
		//ABC...
		for(char i='A'; i<='Z'; i++){
			tableBase64[curseur]= i;
			curseur++ ;
		}
		//abc...
		for(char i='a'; i<='z'; i++){
			tableBase64[curseur]= i;
			curseur++ ;
		}
		//012...
		for(char i='0'; i<='9'; i++){
			tableBase64[curseur]= i;
			curseur++ ;
		}

		tableBase64[curseur]={'+'};
		curseur++;
		tableBase64[curseur]={'/'};

}


void Base64::AfficherTable(){
   //OUTPUT

	for (int k=0; k < 64; k++) {
		cout<<k<<"    ";
		cout<<(char)tableBase64[k]<<"    ";

		AfficherBinaire(k, 6);
		cout<<endl;

	}

}


void Base64::AfficherBinaire(int entier, int nbBits) {
  for(int i=0;i<nbBits;i++) cout<<((entier>>(nbBits-i-1))&0x01);
}

void Base64::Code3OctetsBase64(unsigned char* donnee, char*code){
	int nb24bits,i;
	nb24bits = (donnee[0] << 16)+(donnee[1] << 8) + donnee[2];
	//nb24bit est la concatenation de tout les octets de donnee
	AfficherBinaire(nb24bits, 24);
	//afficher nb24bit
	code[4] = '\0';
	//caractere de fin de chaine 0
	i = nb24bits & 0x3f;
	//garder que 6 bit sur les 24bit
	code[3] = tableBase64[i];
	//prendre les 6 bits et utiliser le base64 correspondant
	nb24bits>>=6;
	//remplacer les 6prochains bits
	i = nb24bits & 0x3f;
	code[2] = tableBase64[i];
	nb24bits>>=6;
	i = nb24bits & 0x3f;
	code[1] = tableBase64[i];
	nb24bits>>=6;
	i = nb24bits & 0x3f;
	code[0] = tableBase64[i];
}

int  Base64::IndiceCaractereBase64(char c){

	if ( (c >= 'A') && (c<='Z') )
		return c -'A';

	else if ( (c >= 'a') && (c<='z') )
		return c - 'a' + 25;

	else if ( (c >= '0') && (c<='9') )
		return c - '0' + 51;

	else if (c=='+') return 62;

	else if (c=='/') return 63;

	else return 64;

}




//---------------------------------------------------------------------------
#pragma package(smart_init)

